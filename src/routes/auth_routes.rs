use std::sync::Arc;

use axum::{
    extract::{State, FromRef},
    response::IntoResponse,
    Json, routing::{put, post}, Router
};

use tower_cookies::Cookies;

use crate::services::{auth_service::{AuthService, error::AuthServiceError}, token_service::TokenService};

use serde::{Deserialize, Serialize};

///
/// Payload for creating a Church User
/// 
#[derive(Debug, Deserialize, Serialize)]
pub struct CreateUserPayload {
    pub email: String,
    pub pwd: String,
    pub card_idx: i64
}

///
/// Payload for the login route
/// Client sent email and password
///
#[derive(Debug, Deserialize, Serialize)]
pub struct LoginPayload {
    pub email: String,
    pub pwd: String,
}

#[derive(Clone, FromRef)]
struct AuthRoutesState {
    auth_service: Arc<dyn AuthService>,
    token_service: Arc<dyn TokenService>
}

///
/// Payload for the authorization route
/// Contains access token generated by this server previously
///
#[derive(Debug, Deserialize, Serialize)]
pub struct AuthPayload {
    pub access_token: String,
}

pub fn routes(auth_service: Arc<dyn AuthService>, token_service: Arc<dyn TokenService>) -> Router {
    Router::new()
        // Routes
        .route("/refresh", put(refresh))
        .route("/login", post(login))
        // State
        .with_state(AuthRoutesState { auth_service, token_service })
}

///
/// Generates new access token and refresh token, using the login information
///
async fn login(
    State(auth_service): State<Arc<dyn AuthService>>,
    cookies: Cookies,
    Json(model): Json<LoginPayload>,
) -> impl IntoResponse {
    auth_service
        .try_accept_creds(model.email, model.pwd)
        .await
        .and_then(|tokens| {
            cookies.add(tokens.refr_token);
            Ok(Json(tokens.access_token))
        })
}

///
/// Attempts to refresh a session with a cookie refresh token,
/// creating a new access and refresh token from the given one
///
async fn refresh(
    State(auth_service): State<Arc<dyn AuthService>>,
    cookies: Cookies,
) -> impl IntoResponse {
    return match cookies.get("refresh-token") {
        Some(refr_token) => {
            let refr_token = refr_token.value().to_string();
            let tokens = auth_service.try_accept_refresh(refr_token.clone()).await?;
            cookies.add(tokens.refr_token);

            Ok(Json(tokens.access_token))
        }
        None => Err(AuthServiceError::CookieNotFound),
    };
}